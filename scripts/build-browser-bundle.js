#!/usr/bin/env node

/**
 * Build script for creating browser bundles (ESM and UMD)
 * Uses esbuild to bundle neozipkit for browser use
 */

const esbuild = require('esbuild');
const { readFileSync, writeFileSync, mkdirSync, existsSync } = require('fs');
const { resolve, dirname } = require('path');

const ROOT_DIR = resolve(__dirname, '..');
const DIST_DIR = resolve(ROOT_DIR, 'dist');
const BROWSER_ESM_DIR = resolve(DIST_DIR, 'browser-esm');
const BROWSER_UMD_DIR = resolve(DIST_DIR, 'browser-umd');

// Ensure directories exist
[BROWSER_ESM_DIR, BROWSER_UMD_DIR].forEach(dir => {
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }
});

// Plugin to replace Node.js crypto with browser-compatible version
const cryptoPlugin = {
  name: 'crypto-replace',
  setup(build) {
    // Replace crypto imports with a browser-compatible shim
    build.onResolve({ filter: /^crypto$/ }, () => {
      return { path: resolve(ROOT_DIR, 'scripts/crypto-browser-shim.js') };
    });
  },
};

// Common build options
const commonOptions = {
  entryPoints: [resolve(ROOT_DIR, 'src/browser/index.esm.ts')],
  bundle: true,
  minify: false,
  sourcemap: true,
  target: 'es2020',
  platform: 'browser',
  // Externalize peer dependencies
  external: ['ethers', 'web3'],
  // Define global for browser
  define: {
    'process.env.NODE_ENV': '"production"',
    'global': 'globalThis',
  },
  // Plugins
  plugins: [cryptoPlugin],
  // Banner for license/copyright
  banner: {
    js: `/*!
 * NeoZipKit Browser Bundle
 * Copyright (c) 2025 NeoWare, Inc. All rights reserved.
 * Licensed under MIT License
 */`,
  },
};

// Build ESM bundle
async function buildESM() {
  console.log('Building ESM bundle...');
  
  try {
    await esbuild.build({
      ...commonOptions,
      format: 'esm',
      outfile: resolve(BROWSER_ESM_DIR, 'index.js'),
      // ESM doesn't need global name
    });
    
    console.log('✓ ESM bundle built successfully');
    return true;
  } catch (error) {
    console.error('✗ ESM bundle build failed:', error);
    return false;
  }
}

// Build UMD bundle
async function buildUMD() {
  console.log('Building UMD bundle...');
  
  try {
    // Development version
    await esbuild.build({
      ...commonOptions,
      format: 'iife',
      globalName: 'NeoZipKit',
      outfile: resolve(BROWSER_UMD_DIR, 'index.js'),
    });
    
    // Minified version
    await esbuild.build({
      ...commonOptions,
      format: 'iife',
      globalName: 'NeoZipKit',
      minify: true,
      outfile: resolve(BROWSER_UMD_DIR, 'index.min.js'),
      sourcemap: false, // Usually skip sourcemaps for minified
    });
    
    console.log('✓ UMD bundle built successfully');
    return true;
  } catch (error) {
    console.error('✗ UMD bundle build failed:', error);
    return false;
  }
}

// Copy type definitions
function copyTypeDefinitions() {
  console.log('Copying type definitions...');
  
  try {
    // For ESM, we need to generate types from the entry point
    // The types will be generated by TypeScript compiler separately
    // For now, we'll copy the existing browser types as a base
    
    const browserIndexDts = resolve(DIST_DIR, 'browser', 'index.d.ts');
    if (existsSync(browserIndexDts)) {
      // Read and modify the type definitions to work with ESM
      let dtsContent = readFileSync(browserIndexDts, 'utf-8');
      
      // Update import paths to be relative to the ESM bundle structure
      // This is a simplified approach - in production, you'd want to regenerate types
      dtsContent = dtsContent.replace(/from ['"]\.\.\/core/g, "from '../core");
      dtsContent = dtsContent.replace(/from ['"]\.\.\/types/g, "from '../types");
      dtsContent = dtsContent.replace(/from ['"]\.\.\/blockchain/g, "from '../blockchain");
      
      writeFileSync(resolve(BROWSER_ESM_DIR, 'index.d.ts'), dtsContent);
      writeFileSync(resolve(BROWSER_UMD_DIR, 'index.d.ts'), dtsContent);
      
      console.log('✓ Type definitions copied');
      return true;
    } else {
      console.warn('⚠ Browser type definitions not found, skipping...');
      return true; // Not a fatal error
    }
  } catch (error) {
    console.error('✗ Failed to copy type definitions:', error);
    return false;
  }
}

// Create Buffer shim for injection
function createBufferShim() {
  const shimPath = resolve(ROOT_DIR, 'scripts/buffer-shim.js');
  if (!existsSync(shimPath)) {
    const shimContent = `// Buffer polyfill injection point
// This file is injected by esbuild to provide Buffer support in browser
import { Buffer } from 'buffer';
globalThis.Buffer = Buffer;
`;
    writeFileSync(shimPath, shimContent);
  }
}

// Main build function
async function build() {
  console.log('Starting browser bundle build...\n');
  
  // Create Buffer shim
  createBufferShim();
  
  // Check command line arguments
  const args = process.argv.slice(2);
  const buildEsm = !args.includes('--umd-only');
  const buildUmd = !args.includes('--esm-only');
  
  let esmSuccess = true;
  let umdSuccess = true;
  
  // Build bundles based on arguments
  if (buildEsm) {
    esmSuccess = await buildESM();
  }
  if (buildUmd) {
    umdSuccess = await buildUMD();
  }
  
  const typesSuccess = copyTypeDefinitions();
  
  if (esmSuccess && umdSuccess && typesSuccess) {
    console.log('\n✓ All browser bundles built successfully!');
    process.exit(0);
  } else {
    console.error('\n✗ Build failed');
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  build();
}

module.exports = { build, buildESM, buildUMD };

